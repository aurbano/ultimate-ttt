{"version":3,"sources":["../../src/model/SubBoard.js"],"names":["ME","OPPONENT","RESULT_TIE","RESULT_WIN","RESULT_LOSE","SubBoard","size","_init","maxMoves","Math","pow","winner","isFinished","gameNotFinished","move","Array","isArray","length","board","player","_move","ret","x","line","y","push","join","moves","copy","_isFull","boardFinished","_isValidPlayer","isValidMove","game","_copy","index","_checkRow","_checkColumn","_checkLtRDiagonal","_checkRtLDiagonal","indexOf","row","i","col"],"mappings":"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","file":"SubBoard.js","sourcesContent":["import errors from './errors';\nimport error from '../error';\nimport Cell from './Cell';\n\nexport const ME = 0;\nexport const OPPONENT = 1;\n\nexport const RESULT_TIE = -1;\nexport const RESULT_WIN = 0;\nexport const RESULT_LOSE = 1;\n\n/**\n * SubBoard for TicTacToe games\n * This class implements the traditional game of TicTacToe\n *\n * Docs: https://github.com/socialgorithm/ultimate-ttt-js/wiki\n */\nexport default class SubBoard {\n  constructor(size = 3){\n    this.size = size;\n    this._init();\n\n    // the maximum number of moves before filling up the board\n    this.maxMoves = Math.pow(this.size, 2);\n\n    return this;\n  }\n\n  /* --------- Public API --------- */\n\n  /**\n   * Returns true if the game is over\n   */\n  isFinished(){\n    return this.winner >= RESULT_TIE;\n  }\n\n  /**\n   * Returns the winner for the game, throws an exception if the game hasn't finished yet.\n   * @returns {number} -1 for a tie, 0 you won, 1 opponent won\n   */\n  getResult() {\n    if (!this.isFinished()) {\n      throw error(errors.gameNotFinished);\n    }\n    return this.winner;\n  }\n\n  /**\n   * Validates a given move (check for right format, data ranges, and\n   * that the move hasn't already been played)\n   * @param move Move coordinates as an array [x, y]\n   * @returns {boolean} true if the move is valid\n   */\n  isValidMove(move){\n    return !(\n      !Array.isArray(move) ||\n      move.length !== 2 ||\n      move[0] < 0 ||\n      move[0] > this.size ||\n      move[1] < 0 ||\n      move[1] > this.size ||\n      typeof(this.board[move[0]][move[1]]) === 'undefined' ||\n      this.board[move[0]][move[1]].player >= ME\n    );\n  }\n\n  /**\n   * Adds your move to the board, throws exception if move is invalid or board is already finished.\n   * @param move\n   * @returns {SubBoard}\n   */\n  addMyMove(move) {\n    return this._move(ME, move);\n  }\n\n  /**\n   * Adds an opponent move to the board, throws exception if move is invalid or board is already finished.\n   * @param move\n   * @returns {SubBoard}\n   */\n  addOpponentMove(move) {\n    return this._move(OPPONENT, move)\n  }\n\n  /**\n   * Returns a string with the board formatted for display\n   * including new lines.\n   * @returns {string}\n   */\n  prettyPrint(){\n    let ret = [];\n    for(let x = 0; x < this.size; x++) {\n      let line = '';\n      for (let y = 0; y < this.size; y++) {\n        const player = (this.board[x][y].player < 0)? '-' : this.board[x][y].player;\n        line += player + ' ';\n      }\n      ret.push(line);\n    }\n    return ret.join(\"\\n\");\n  }\n\n  /* --------- Private API --------- */\n\n  /**\n   * Initialise the game\n   * In normal usage you should create a new SubBoard object for this\n   * but sometimes it may be useful to reset the current instance.\n   * @private\n   */\n  _init(){\n    this.board = [];\n    this.moves = 0;\n    this.winner = RESULT_TIE - 1;\n\n    for(let x = 0; x < this.size; x++){\n      this.board[x] = [];\n      for(let y = 0; y < this.size; y++){\n        this.board[x][y] = new Cell();\n      }\n    }\n  }\n\n  /**\n   * Return a new SubBoard as a copy of this one\n   * @returns {SubBoard} Copy of the current game\n   * @private\n   */\n  _copy() {\n    const copy = new SubBoard(this.size);\n    copy._init();\n    copy.board = this.board;\n    copy.moves = this.moves;\n    copy.winner = this.winner;\n    return copy;\n  }\n\n  /**\n   * Execute a move. This is an immutable method, that returns a\n   * new SubBoard.\n   * @param player Player identifier (0 || 1)\n   * @param move Move coordinates as an array [x, y]\n   * @returns {SubBoard} Updated copy of the current game with the move added and the state updated\n   * @private\n   */\n  _move(player, move){\n    if(this._isFull() || this.isFinished()) {\n      throw error(errors.boardFinished);\n    }\n\n    if (!this._isValidPlayer(player)) {\n      throw error(errors.player, player);\n    }\n\n    if (!this.isValidMove(move)) {\n      throw error(errors.move, move);\n    }\n    const game = this._copy();\n\n    game.board[move[0]][move[1]].player = player;\n    game.board[move[0]][move[1]].index = this.moves;\n    game.moves++;\n\n    // Check if the board has been won\n    game._checkRow(move[0]);\n\n    if (!game.isFinished()) {\n      game._checkColumn(move[1]);\n    }\n\n    if (!game.isFinished()) {\n      game._checkLtRDiagonal();\n    }\n\n    if (!game.isFinished()) {\n      game._checkRtLDiagonal();\n    }\n\n    // check for a tie\n    if (game._isFull() && game.winner < RESULT_TIE){\n      game.winner = RESULT_TIE;\n    }\n\n    return game;\n  }\n\n  /**\n   * Validates a player\n   * @param player Player identifier (0 || 1)\n   * @returns {boolean}\n   * @private\n   */\n  _isValidPlayer(player){\n    return [ ME, OPPONENT ].indexOf(player) > -1;\n  }\n\n  /**\n   * Check if a given row has been won\n   * @param row Row index\n   * @private\n   */\n  _checkRow(row){\n    const player = this.board[row][0].player;\n    if(player < ME){\n      return;\n    }\n    for(let i = 1; i < this.size; i++){\n      if(player !== this.board[row][i].player) {\n        return;\n      }\n    }\n    if (player >= ME) {\n      this.winner = player;\n    }\n  }\n\n  /**\n   * Check if a given column has been won\n   * @param col Column index\n   * @private\n   */\n  _checkColumn(col){\n    const player = this.board[0][col].player;\n    if(player < ME){\n      return;\n    }\n    for(let i = 1; i < this.size; i++){\n      if(player !== this.board[i][col].player) {\n        return;\n      }\n    }\n    if (player >= ME) {\n      this.winner = player;\n    }\n  }\n\n  /**\n   * Check if the left to right diagonal has been won\n   * @private\n   */\n  _checkLtRDiagonal(){\n    const player = this.board[0][0].player;\n    if(player < ME){\n      return;\n    }\n    for(let i = 1; i < this.size; i++){\n      if(player !== this.board[i][i].player){\n        return;\n      }\n    }\n    if (player >= ME) {\n      this.winner = player;\n    }\n  }\n\n  /**\n   * Check if the right to left diagonal has been won\n   * @private\n   */\n  _checkRtLDiagonal(){\n    const player = this.board[0][this.size - 1].player;\n    if(player < ME){\n      return;\n    }\n    for(let i = this.size - 1; i >= 0; i--){\n      if(player !== this.board[this.size - 1 - i][i].player){\n        return;\n      }\n    }\n    if (player >= ME) {\n      this.winner = player;\n    }\n  }\n\n  /**\n   * Check if the board is full\n   * @returns {boolean}\n   * @private\n   */\n  _isFull(){\n    return this.moves === this.maxMoves;\n  }\n}"]}